/*
 * CMutexLock.cpp
 *
 *  Created on: 2015-4-22
 *      Author: root
 */

#include "CMutexLock.h"
#include "../log/CLog.h"
#include "../../../osi/Osi.h"

CMutexLock::CMutexLock()
{
	OsiCreateMutex(&m_mutex);
}

CMutexLock::~CMutexLock()
{
	OsiDestroyMutex(&m_mutex);
}

int8_t CMutexLock::Create()
{
	if (0 != OsiCreateMutex(&m_mutex))
	{
		return 1;
	}
	return 0;
}

void CMutexLock::Lock()
{
	OsiLockMutex(&m_mutex);
}

void CMutexLock::UnLock()
{
	OsiUnLockMutex(&m_mutex);
}

CLockGuard::CLockGuard(CMutexLock *pLock):m_pLock(pLock),m_isLock(false)
{
}

CLockGuard::~CLockGuard()
{
	Unlock();
}

void CLockGuard::Lock()
{
	if (m_isLock || m_pLock == NULL)
	{
		return;
	}
	m_pLock->Lock();
	m_isLock = true;
}

void CLockGuard::Unlock()
{
	if (!m_isLock || m_pLock == NULL)
	{
		return;
	}
	m_pLock->UnLock();
	m_isLock = false;
}

CMutexCondition::CMutexCondition():p_mutex(NULL)
{
	pthread_cond_init(&m_cond, NULL);
}

CMutexCondition::CMutexCondition(CMutexLock *pLock)
{
	p_mutex = NULL;
	if (pLock)
	{
		p_mutex = &pLock->m_mutex;
	}
	pthread_cond_init(&m_cond, NULL);
}

CMutexCondition::~CMutexCondition()
{
	pthread_cond_destroy(&m_cond);
}

void CMutexCondition::signal()
{
	if (NULL == p_mutex)
	{
		return;
	}
	pthread_cond_signal(&m_cond);
}

void CMutexCondition::Wait()
{
	if (NULL == p_mutex)
	{
		return;
	}
	pthread_cond_wait(&m_cond, p_mutex);
}

int32_t CMutexCondition::TimeWait(int32_t seconds)
{
	if (NULL == p_mutex)
	{
		return -1;
	}
	struct timespec tt;
	tt.tv_sec = time(NULL) + seconds;
	tt.tv_nsec = 0;
	return pthread_cond_timedwait(&m_cond, p_mutex, &tt);
}
